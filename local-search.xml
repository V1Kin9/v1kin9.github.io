<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CPU-ARM-Hardfault-Thumb指令与ARM指令</title>
    <link href="/2024/09/05/Thumb_and_arm_inst/"/>
    <url>/2024/09/05/Thumb_and_arm_inst/</url>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近调试遇到一个很有趣的问题：某ARM程序需要实现一个跳转，该跳转目标是一个绝对地址，在实现跳转的时候，直接运行会触发异常，但单步调试却可以正常执行。</p><h2 id="原因分析思路"><a href="#原因分析思路" class="headerlink" title="原因分析思路"></a>原因分析思路</h2><ol><li><p>首先，该跳转的函数实现是通过内嵌汇编汇编实现的，使用的是BX指令，该指令会跳转到对应的寄存器中的目标地址，同时会把该指令的下一条指令（即BX指令在本上下文中的下一条指令）写到LR寄存器中，用于返回。</p></li><li><p>BX指令是具有切换架构状态的能力，即可以切换架构为ARM或Thumb状态。Thumb指令是16 bit（Thumb-2是32 bit）的，而ARM指令是32 bit。</p></li><li><p>在调试的过程中，看到J-Link-commander会提示架构与指令不符的提示，然后有自动修改CPSR.T的操作（把对应的bit修改为合法的值）<br><a href="https://wiki.segger.com/J-Link_Command_Strings#DisableCortexMXPSRAutoCorrectTBit">https://wiki.segger.com/J-Link_Command_Strings#DisableCortexMXPSRAutoCorrectTBit</a></p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过以上现象，可以推断出，这个问题有可能是这样触发的：</p><ol><li>跳转的目标地址指令与当前的架构不一致</li><li>在单步调试的过程中，J-Link-Commander对对应的寄存器作了修改，导致单步调试时可以正常运行，而全速run或直接执行时，则会触发异常<br><a href="https://chatgpt.com/share/90ccfa35-b798-44e2-aaa1-40bf9844a15f">https://chatgpt.com/share/90ccfa35-b798-44e2-aaa1-40bf9844a15f</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
